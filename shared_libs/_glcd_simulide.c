#include <avr/io.h>
#define F_CPU 16000000UL
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

#include "_main.h"
#include "_glcd.h"

typedef unsigned char byte;
typedef unsigned int word;

// Timing constants for SimulIDE compatibility
#define D_BEFORE 2
#define D_AFTER 50
#define D_MIDDLE 1

#define DISPON 0x3f
#define DISPOFF 0x3e

// Global variables
byte xchar, ychar;

/* LCD Control Pin Definitions:
 * RS pin PE4 [L:command, H:data]
 * E pin PE5 [L->H pulse: latch]
 * CS1 pin PE7 [L: left controller active]
 * CS2 pin PE6 [L: right controller active]
 * RW pin PG1 [L:write, H:read]
 * Data bus: PA0-PA7
 */

void glcd_port_init(void)
{
    // Set up port directions for GLCD
    SetBit(DDRA, DDA0);
    SetBit(DDRA, DDA1);
    SetBit(DDRA, DDA2);
    SetBit(DDRA, DDA3);
    SetBit(DDRA, DDA4);
    SetBit(DDRA, DDA5);
    SetBit(DDRA, DDA6);
    SetBit(DDRA, DDA7);
    SetBit(DDRE, DDE4);
    SetBit(DDRE, DDE5);
    SetBit(DDRE, DDE6);
    SetBit(DDRE, DDE7);
    SetBit(DDRG, DDG1); // RW pin as output

    // Initialize control signals to safe state
    ClrBit(PORTE, PORTE4); // RS = 0
    ClrBit(PORTE, PORTE5); // E = 0
    ClrBit(PORTE, PORTE6); // CS2 = 0
    ClrBit(PORTE, PORTE7); // CS1 = 0
    ClrBit(PORTG, PORTG1); // RW = 0 (write mode)
    PORTA = 0x00;          // Clear data bus

    _delay_ms(50); // Allow ports to stabilize
}

// Minimal font table stored in RAM to avoid PROGMEM/ELPM issues
// Basic ASCII characters: space, numbers, some letters and symbols
byte mini_font[96][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // 0x20 space
    {0x00, 0x00, 0x4f, 0x00, 0x00}, // 0x21 !
    {0x00, 0x07, 0x00, 0x07, 0x00}, // 0x22 "
    {0x14, 0x7f, 0x14, 0x7f, 0x14}, // 0x23 #
    {0x24, 0x2a, 0x7f, 0x2a, 0x12}, // 0x24 $
    {0x23, 0x13, 0x08, 0x64, 0x62}, // 0x25 %
    {0x36, 0x49, 0x55, 0x22, 0x50}, // 0x26 &
    {0x00, 0x05, 0x03, 0x00, 0x00}, // 0x27 '
    {0x00, 0x1c, 0x22, 0x41, 0x00}, // 0x28 (
    {0x00, 0x41, 0x22, 0x1c, 0x00}, // 0x29 )
    {0x14, 0x08, 0x3e, 0x08, 0x14}, // 0x2a *
    {0x08, 0x08, 0x3e, 0x08, 0x08}, // 0x2b +
    {0x00, 0x50, 0x30, 0x00, 0x00}, // 0x2c ,
    {0x08, 0x08, 0x08, 0x08, 0x08}, // 0x2d -
    {0x00, 0x60, 0x60, 0x00, 0x00}, // 0x2e .
    {0x20, 0x10, 0x08, 0x04, 0x02}, // 0x2f /
    {0x3e, 0x51, 0x49, 0x45, 0x3e}, // 0x30 0
    {0x00, 0x42, 0x7f, 0x40, 0x00}, // 0x31 1
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 0x32 2
    {0x21, 0x41, 0x45, 0x4b, 0x31}, // 0x33 3
    {0x18, 0x14, 0x12, 0x7f, 0x10}, // 0x34 4
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 0x35 5
    {0x3c, 0x4a, 0x49, 0x49, 0x30}, // 0x36 6
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 0x37 7
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 0x38 8
    {0x06, 0x49, 0x49, 0x29, 0x1e}, // 0x39 9
    {0x00, 0x36, 0x36, 0x00, 0x00}, // 0x3a :
    {0x00, 0x56, 0x36, 0x00, 0x00}, // 0x3b ;
    {0x08, 0x14, 0x22, 0x41, 0x00}, // 0x3c <
    {0x14, 0x14, 0x14, 0x14, 0x14}, // 0x3d =
    {0x00, 0x41, 0x22, 0x14, 0x08}, // 0x3e >
    {0x02, 0x01, 0x51, 0x09, 0x06}, // 0x3f ?
    {0x32, 0x49, 0x59, 0x51, 0x3e}, // 0x40 @
    {0x7c, 0x12, 0x11, 0x12, 0x7c}, // 0x41 A
    {0x7f, 0x49, 0x49, 0x49, 0x36}, // 0x42 B
    {0x3e, 0x41, 0x41, 0x41, 0x22}, // 0x43 C
    {0x7f, 0x41, 0x41, 0x22, 0x1c}, // 0x44 D
    {0x7f, 0x49, 0x49, 0x49, 0x41}, // 0x45 E
    {0x7f, 0x09, 0x09, 0x09, 0x01}, // 0x46 F
    {0x3e, 0x41, 0x49, 0x49, 0x7a}, // 0x47 G
    {0x7f, 0x08, 0x08, 0x08, 0x7f}, // 0x48 H
    {0x00, 0x41, 0x7f, 0x41, 0x00}, // 0x49 I
    {0x20, 0x40, 0x41, 0x3f, 0x01}, // 0x4a J
    {0x7f, 0x08, 0x14, 0x22, 0x41}, // 0x4b K
    {0x7f, 0x40, 0x40, 0x40, 0x40}, // 0x4c L
    {0x7f, 0x02, 0x0c, 0x02, 0x7f}, // 0x4d M
    {0x7f, 0x04, 0x08, 0x10, 0x7f}, // 0x4e N
    {0x3e, 0x41, 0x41, 0x41, 0x3e}, // 0x4f O
    {0x7f, 0x09, 0x09, 0x09, 0x06}, // 0x50 P
    {0x3e, 0x41, 0x51, 0x21, 0x5e}, // 0x51 Q
    {0x7f, 0x09, 0x19, 0x29, 0x46}, // 0x52 R
    {0x46, 0x49, 0x49, 0x49, 0x31}, // 0x53 S
    {0x01, 0x01, 0x7f, 0x01, 0x01}, // 0x54 T
    {0x3f, 0x40, 0x40, 0x40, 0x3f}, // 0x55 U
    {0x1f, 0x20, 0x40, 0x20, 0x1f}, // 0x56 V
    {0x3f, 0x40, 0x38, 0x40, 0x3f}, // 0x57 W
    {0x63, 0x14, 0x08, 0x14, 0x63}, // 0x58 X
    {0x07, 0x08, 0x70, 0x08, 0x07}, // 0x59 Y
    {0x61, 0x51, 0x49, 0x45, 0x43}, // 0x5a Z
    {0x00, 0x7f, 0x41, 0x41, 0x00}, // 0x5b [
    {0x02, 0x04, 0x08, 0x10, 0x20}, // 0x5c backslash
    {0x00, 0x41, 0x41, 0x7f, 0x00}, // 0x5d ]
    {0x04, 0x02, 0x01, 0x02, 0x04}, // 0x5e ^
    {0x40, 0x40, 0x40, 0x40, 0x40}, // 0x5f _
    {0x00, 0x01, 0x02, 0x04, 0x00}, // 0x60 `
    {0x20, 0x54, 0x54, 0x54, 0x78}, // 0x61 a
    {0x7f, 0x48, 0x44, 0x44, 0x38}, // 0x62 b
    {0x38, 0x44, 0x44, 0x44, 0x20}, // 0x63 c
    {0x38, 0x44, 0x44, 0x48, 0x7f}, // 0x64 d
    {0x38, 0x54, 0x54, 0x54, 0x18}, // 0x65 e
    {0x08, 0x7e, 0x09, 0x01, 0x02}, // 0x66 f
    {0x0c, 0x52, 0x52, 0x52, 0x3e}, // 0x67 g
    {0x7f, 0x08, 0x04, 0x04, 0x78}, // 0x68 h
    {0x00, 0x44, 0x7d, 0x40, 0x00}, // 0x69 i
    {0x20, 0x40, 0x44, 0x3d, 0x00}, // 0x6a j
    {0x7f, 0x10, 0x28, 0x44, 0x00}, // 0x6b k
    {0x00, 0x41, 0x7f, 0x40, 0x00}, // 0x6c l
    {0x7c, 0x04, 0x18, 0x04, 0x78}, // 0x6d m
    {0x7c, 0x08, 0x04, 0x04, 0x78}, // 0x6e n
    {0x38, 0x44, 0x44, 0x44, 0x38}, // 0x6f o
    {0x7c, 0x14, 0x14, 0x14, 0x08}, // 0x70 p
    {0x08, 0x14, 0x14, 0x18, 0x7c}, // 0x71 q
    {0x7c, 0x08, 0x04, 0x04, 0x08}, // 0x72 r
    {0x48, 0x54, 0x54, 0x54, 0x20}, // 0x73 s
    {0x04, 0x3f, 0x44, 0x40, 0x20}, // 0x74 t
    {0x3c, 0x40, 0x40, 0x20, 0x7c}, // 0x75 u
    {0x1c, 0x20, 0x40, 0x20, 0x1c}, // 0x76 v
    {0x3c, 0x40, 0x30, 0x40, 0x3c}, // 0x77 w
    {0x44, 0x28, 0x10, 0x28, 0x44}, // 0x78 x
    {0x0c, 0x50, 0x50, 0x50, 0x3c}, // 0x79 y
    {0x44, 0x64, 0x54, 0x4c, 0x44}, // 0x7a z
    {0x00, 0x08, 0x36, 0x41, 0x00}, // 0x7b {
    {0x00, 0x00, 0x7f, 0x00, 0x00}, // 0x7c |
    {0x00, 0x41, 0x36, 0x08, 0x00}, // 0x7d }
    {0x10, 0x08, 0x08, 0x10, 0x08}, // 0x7e ~
    {0x78, 0x46, 0x41, 0x46, 0x78}  // 0x7f DEL
};

void cmndl(byte cmd) // left 128x64
{
    ClrBit(PORTG, PORTG1); // RW = 0 (write mode)
    ClrBit(PORTE, PORTE4); // RS = 0 (command mode)
    SetBit(PORTE, PORTE7); // CS1 = 1 (left controller)
    ClrBit(PORTE, PORTE6); // CS2 = 0
    _delay_us(D_BEFORE);

    PORTA = cmd;
    _delay_us(D_MIDDLE);
    SetBit(PORTE, PORTE5); // E = 1
    _delay_us(D_MIDDLE);
    ClrBit(PORTE, PORTE5); // E = 0
    _delay_us(D_AFTER);
}

void cmndr(byte cmd) // right 128x64
{
    ClrBit(PORTG, PORTG1); // RW = 0 (write mode)
    ClrBit(PORTE, PORTE4); // RS = 0 (command mode)
    ClrBit(PORTE, PORTE7); // CS1 = 0
    SetBit(PORTE, PORTE6); // CS2 = 1 (right controller)
    _delay_us(D_BEFORE);

    PORTA = cmd;
    _delay_us(D_MIDDLE);
    SetBit(PORTE, PORTE5); // E = 1
    _delay_us(D_MIDDLE);
    ClrBit(PORTE, PORTE5); // E = 0
    _delay_us(D_AFTER);
}

void cmnda(byte cmd) // both 128x64
{
    cmndl(cmd);
    cmndr(cmd);
}

void datal(byte dat) // left 128x64
{
    ClrBit(PORTG, PORTG1); // RW = 0 (write mode)
    SetBit(PORTE, PORTE4); // RS = 1 (data mode)
    SetBit(PORTE, PORTE7); // CS1 = 1 (left controller)
    ClrBit(PORTE, PORTE6); // CS2 = 0
    _delay_us(D_BEFORE);

    PORTA = dat;
    _delay_us(D_MIDDLE);
    SetBit(PORTE, PORTE5); // E = 1
    _delay_us(D_MIDDLE);
    ClrBit(PORTE, PORTE5); // E = 0
    _delay_us(D_AFTER);
}

void datar(byte dat) // right 128x64
{
    ClrBit(PORTG, PORTG1); // RW = 0 (write mode)
    SetBit(PORTE, PORTE4); // RS = 1 (data mode)
    ClrBit(PORTE, PORTE7); // CS1 = 0
    SetBit(PORTE, PORTE6); // CS2 = 1 (right controller)
    _delay_us(D_BEFORE);

    PORTA = dat;
    _delay_us(D_MIDDLE);
    SetBit(PORTE, PORTE5); // E = 1
    _delay_us(D_MIDDLE);
    ClrBit(PORTE, PORTE5); // E = 0
    _delay_us(D_AFTER);
}

void dataa(byte dat) // both 128x64
{
    datal(dat);
    datar(dat);
}

void lcd_clear(void) /* clear LCD screen */
{
    byte x, y;

    for (x = 0; x <= 7; x++)
    {
        cmnda(0xb8 | x); // set page
        cmnda(0x40);     // set column to 0

        for (y = 0; y <= 63; y++)
        {
            dataa(0x00);
        }
        _delay_ms(10);
    }
}

/* GLCD Initialize */
void lcd_init(void)
{
    // Initialize ports first
    glcd_port_init();

    // Enhanced initialization for SimulIDE compatibility
    _delay_ms(100);

    // Reset both controllers first
    cmnda(DISPOFF); // Display OFF first
    _delay_ms(10);

    // Initialize both controllers
    cmnda(DISPON); // Display ON
    _delay_ms(10);
    cmnda(0xc0); // z = 0 first line (start line 0)
    _delay_ms(5);
    cmnda(0xb8); // x = 0 first page (page 0)
    _delay_ms(5);
    cmnda(0x40); // y = 0 first column (column 0)
    _delay_ms(10);

    // Additional stabilization
    _delay_ms(50);
}

void lcd_xy(byte x, byte y)
{
    xchar = x;
    ychar = y;
    cmnda(0xb8 | xchar); // set page
    if (ychar <= 9)
        cmndl(0x40 | (ychar * 6)); // left controller
    else
        cmndr(0x40 | ((ychar - 10) * 6)); // right controller
}

/* Simple character output - full ASCII support */
void lcd_char(byte character)
{
    byte i;
    byte *pattern;

    // Select pattern based on character
    if (character >= 0x20 && character <= 0x7F)
    {
        pattern = mini_font[character - 0x20];
    }
    else
    {
        pattern = mini_font[0]; // default to space for unknown chars
    }

    for (i = 0; i <= 4; i++)
    {
        if (ychar <= 9) /* if y <= 9, CS1 */
            datal(pattern[i]);
        else /* if y >= 10, CS2 */
            datar(pattern[i]);
    }
    if (ychar <= 9)
        datal(0x00); /* spacing */
    else
        datar(0x00); /* spacing */
}

/* Simple string output */
void lcd_string(byte x, byte y, char *string)
{
    xchar = x;
    ychar = y;
    cmnda(0xb8 | xchar); // set page

    while (*string)
    {
        if (ychar <= 9)
            cmndl(0x40 | (ychar * 6)); // left controller
        else
            cmndr(0x40 | ((ychar - 10) * 6)); // right controller

        lcd_char(*string);
        string++;
        ychar++;
        if (ychar > 19)
            break; // prevent overflow
    }
}

// Minimal graphics functions
void GLCD_Axis_xy(unsigned char x, unsigned char y)
{
    if (x > 63 || y > 127)
        return;

    byte page = x / 8;
    byte bit = x % 8;
    byte pattern = 1 << bit;

    cmnda(0xb8 | page); // set page

    if (y <= 63)
    {
        cmndl(0x40 | y); // set column left
        datal(pattern);
    }
    else
    {
        cmndr(0x40 | (y - 64)); // set column right
        datar(pattern);
    }
}

void GLCD_Dot(unsigned char x, unsigned char y)
{
    GLCD_Axis_xy(x, y);
}

void GLCD_Line(unsigned char x1, unsigned char y1, unsigned char x2, unsigned char y2)
{
    // Simple line drawing - just draw endpoints for now
    GLCD_Dot(x1, y1);
    GLCD_Dot(x2, y2);
}

void GLCD_Rectangle(unsigned char x1, unsigned char y1, unsigned char x2, unsigned char y2)
{
    // Simple rectangle - just corners
    GLCD_Dot(x1, y1);
    GLCD_Dot(x1, y2);
    GLCD_Dot(x2, y1);
    GLCD_Dot(x2, y2);
}

void GLCD_Circle(unsigned char x, unsigned char y, unsigned char r)
{
    // Simple circle - just center dot
    GLCD_Dot(x, y);
}

void GLCD_4DigitDecimal(unsigned int number)
{
    char buffer[5];
    sprintf(buffer, "%04u", number);

    for (int i = 0; i < 4; i++)
    {
        lcd_char(buffer[i]);
        ychar++;
    }
}

void GLCD_2DigitDecimal(unsigned char number)
{
    char buffer[3];
    sprintf(buffer, "%02u", number);

    lcd_char(buffer[0]);
    ychar++;
    lcd_char(buffer[1]);
    ychar++;
}

void GLCD_3DigitDecimal(unsigned int number)
{
    char buffer[4];
    sprintf(buffer, "%03u", number);

    for (int i = 0; i < 3; i++)
    {
        lcd_char(buffer[i]);
        ychar++;
    }
}

// Additional functions needed by Graphics_Display
void ScreenBuffer_clear(void)
{
    // Simple clear - just call lcd_clear
    lcd_clear();
}